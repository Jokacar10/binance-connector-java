/*
 * Binance Simple Earn REST API
 * OpenAPI Specification for the Binance Simple Earn REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.simple_earn.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.simple_earn.rest.model.GetCollateralRecordResponse;
import com.binance.connector.client.simple_earn.rest.model.GetFlexiblePersonalLeftQuotaResponse;
import com.binance.connector.client.simple_earn.rest.model.GetFlexibleProductPositionResponse;
import com.binance.connector.client.simple_earn.rest.model.GetFlexibleRedemptionRecordResponse;
import com.binance.connector.client.simple_earn.rest.model.GetFlexibleRewardsHistoryResponse;
import com.binance.connector.client.simple_earn.rest.model.GetFlexibleSubscriptionPreviewResponse;
import com.binance.connector.client.simple_earn.rest.model.GetFlexibleSubscriptionRecordResponse;
import com.binance.connector.client.simple_earn.rest.model.GetLockedPersonalLeftQuotaResponse;
import com.binance.connector.client.simple_earn.rest.model.GetLockedProductPositionResponse;
import com.binance.connector.client.simple_earn.rest.model.GetLockedRedemptionRecordResponse;
import com.binance.connector.client.simple_earn.rest.model.GetLockedRewardsHistoryResponse;
import com.binance.connector.client.simple_earn.rest.model.GetLockedSubscriptionPreviewResponse;
import com.binance.connector.client.simple_earn.rest.model.GetLockedSubscriptionRecordResponse;
import com.binance.connector.client.simple_earn.rest.model.GetRateHistoryResponse;
import com.binance.connector.client.simple_earn.rest.model.GetSimpleEarnFlexibleProductListResponse;
import com.binance.connector.client.simple_earn.rest.model.GetSimpleEarnLockedProductListResponse;
import com.binance.connector.client.simple_earn.rest.model.RedeemFlexibleProductRequest;
import com.binance.connector.client.simple_earn.rest.model.RedeemFlexibleProductResponse;
import com.binance.connector.client.simple_earn.rest.model.RedeemLockedProductRequest;
import com.binance.connector.client.simple_earn.rest.model.RedeemLockedProductResponse;
import com.binance.connector.client.simple_earn.rest.model.SetFlexibleAutoSubscribeRequest;
import com.binance.connector.client.simple_earn.rest.model.SetFlexibleAutoSubscribeResponse;
import com.binance.connector.client.simple_earn.rest.model.SetLockedAutoSubscribeRequest;
import com.binance.connector.client.simple_earn.rest.model.SetLockedAutoSubscribeResponse;
import com.binance.connector.client.simple_earn.rest.model.SetLockedProductRedeemOptionRequest;
import com.binance.connector.client.simple_earn.rest.model.SetLockedProductRedeemOptionResponse;
import com.binance.connector.client.simple_earn.rest.model.SimpleAccountResponse;
import com.binance.connector.client.simple_earn.rest.model.SubscribeFlexibleProductRequest;
import com.binance.connector.client.simple_earn.rest.model.SubscribeFlexibleProductResponse;
import com.binance.connector.client.simple_earn.rest.model.SubscribeLockedProductRequest;
import com.binance.connector.client.simple_earn.rest.model.SubscribeLockedProductResponse;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for AccountApi */
public class FlexibleLockedApiTest {

    private FlexibleLockedApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new FlexibleLockedApi(apiClientSpy);
    }

    /**
     * Get Flexible Personal Left Quota(USER_DATA)
     *
     * <p>Get Flexible Personal Left Quota Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFlexiblePersonalLeftQuotaTest() throws ApiException, CryptoException {
        String productId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetFlexiblePersonalLeftQuotaResponse> response =
                api.getFlexiblePersonalLeftQuota(productId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "productId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "3449171bcce7a8aa43ee9684da7eebf17feeecb24ed8fd2858ca78fcc5d87e85",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/flexible/personalLeftQuota",
                actualRequest.url().encodedPath());
    }

    /**
     * Get Flexible Product Position(USER_DATA)
     *
     * <p>Get Flexible Product Position Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFlexibleProductPositionTest() throws ApiException, CryptoException {
        String asset = "";
        String productId = "1";
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetFlexibleProductPositionResponse> response =
                api.getFlexibleProductPosition(asset, productId, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&productId=1&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "1cc1b386baba7fc174869f28bbc9dcbfff30e18b98f074dd3f90eadd0fee8692",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/simple-earn/flexible/position", actualRequest.url().encodedPath());
    }

    /**
     * Get Locked Personal Left Quota(USER_DATA)
     *
     * <p>Get Locked Personal Left Quota Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getLockedPersonalLeftQuotaTest() throws ApiException, CryptoException {
        String projectId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetLockedPersonalLeftQuotaResponse> response =
                api.getLockedPersonalLeftQuota(projectId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "projectId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "7df8536b8711da59322819086e27ee0e183d18d1f4d6a68377c9c4a87f835ab8",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/locked/personalLeftQuota", actualRequest.url().encodedPath());
    }

    /**
     * Get Locked Product Position
     *
     * <p>Get Locked Product Position Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getLockedProductPositionTest() throws ApiException, CryptoException {
        String asset = "";
        String positionId = "1";
        String projectId = "1";
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetLockedProductPositionResponse> response =
                api.getLockedProductPosition(
                        asset, positionId, projectId, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("3fa625e0c98e6f4e9f1ec21a44584f64734fa62a263ad96d4bea3583baa409d7", actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/simple-earn/locked/position", actualRequest.url().encodedPath());
    }

    /**
     * Get Simple Earn Flexible Product List(USER_DATA)
     *
     * <p>Get available Simple Earn flexible product list Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSimpleEarnFlexibleProductListTest() throws ApiException, CryptoException {
        String asset = "";
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetSimpleEarnFlexibleProductListResponse> response =
                api.getSimpleEarnFlexibleProductList(asset, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a8d7174d9767b6c5ac9e2a1b5c161cef80476f7dbb006361943091d5b77cd212",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/simple-earn/flexible/list", actualRequest.url().encodedPath());
    }

    /**
     * Get Simple Earn Locked Product List(USER_DATA)
     *
     * <p>Get Simple Earn Locked Product List * Get available Simple Earn locked product list
     * Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSimpleEarnLockedProductListTest() throws ApiException, CryptoException {
        String asset = "";
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetSimpleEarnLockedProductListResponse> response =
                api.getSimpleEarnLockedProductList(asset, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a8d7174d9767b6c5ac9e2a1b5c161cef80476f7dbb006361943091d5b77cd212",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/simple-earn/locked/list", actualRequest.url().encodedPath());
    }

    /**
     * Simple Account(USER_DATA)
     *
     * <p>Simple Account query Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void simpleAccountTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<SimpleAccountResponse> response = api.simpleAccount(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/simple-earn/account", actualRequest.url().encodedPath());
    }

    /**
     * Get Flexible Subscription Preview(USER_DATA)
     *
     * <p>Get Flexible Subscription Preview Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFlexibleSubscriptionPreviewTest() throws ApiException, CryptoException {
        String productId = "1";
        Double amount = 1d;
        Long recvWindow = 5000L;
        ApiResponse<GetFlexibleSubscriptionPreviewResponse> response =
                api.getFlexibleSubscriptionPreview(productId, amount, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "productId=1&amount=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "00a7c80c0c410b10c6a3067e01f82fc810a365b87c83c5086e7224f826896ff5",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/flexible/subscriptionPreview",
                actualRequest.url().encodedPath());
    }

    /**
     * Get Locked Subscription Preview(USER_DATA)
     *
     * <p>Get Locked Subscription Preview Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getLockedSubscriptionPreviewTest() throws ApiException, CryptoException {
        String projectId = "1";
        Double amount = 1d;
        Boolean autoSubscribe = false;
        Long recvWindow = 5000L;
        ApiResponse<GetLockedSubscriptionPreviewResponse> response =
                api.getLockedSubscriptionPreview(projectId, amount, autoSubscribe, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "projectId=1&amount=1&autoSubscribe=false&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "ed6d60bbbd167523b7f2ff4be5baa4485dbf0f39322a1cb34907612d59aac34a",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/locked/subscriptionPreview",
                actualRequest.url().encodedPath());
    }

    /**
     * Redeem Flexible Product(TRADE)
     *
     * <p>Redeem Flexible Product * You need to open &#x60;Enable Spot &amp; Margin Trading&#x60;
     * permission for the API Key which requests this endpoint. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void redeemFlexibleProductTest() throws ApiException, CryptoException {
        RedeemFlexibleProductRequest redeemFlexibleProductRequest =
                new RedeemFlexibleProductRequest();

        redeemFlexibleProductRequest.productId("1");

        ApiResponse<RedeemFlexibleProductResponse> response =
                api.redeemFlexibleProduct(redeemFlexibleProductRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000productId=1", signInputCaptor.getValue());
        assertEquals(
                "c4c7af86a6a8cfafc9909bb0dec0f67695e17aba2a88ca75e983de6e0b915279",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/simple-earn/flexible/redeem", actualRequest.url().encodedPath());
    }

    /**
     * Redeem Locked Product(TRADE)
     *
     * <p>Redeem Locked Product * You need to open &#x60;Enable Spot &amp; Margin Trading&#x60;
     * permission for the API Key which requests this endpoint. Weight: 1/3s per account
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void redeemLockedProductTest() throws ApiException, CryptoException {
        RedeemLockedProductRequest redeemLockedProductRequest = new RedeemLockedProductRequest();

        redeemLockedProductRequest.positionId("1");

        ApiResponse<RedeemLockedProductResponse> response =
                api.redeemLockedProduct(redeemLockedProductRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000positionId=1", signInputCaptor.getValue());
        assertEquals(
                "05345189012e725ecf394a569c76b468c3a9d6377f5b644a1b90e1551920ce91",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/simple-earn/locked/redeem", actualRequest.url().encodedPath());
    }

    /**
     * Set Flexible Auto Subscribe(USER_DATA)
     *
     * <p>Set Flexible Auto Subscribe Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setFlexibleAutoSubscribeTest() throws ApiException, CryptoException {
        SetFlexibleAutoSubscribeRequest setFlexibleAutoSubscribeRequest =
                new SetFlexibleAutoSubscribeRequest();

        setFlexibleAutoSubscribeRequest.productId("1");
        setFlexibleAutoSubscribeRequest.autoSubscribe(false);

        ApiResponse<SetFlexibleAutoSubscribeResponse> response =
                api.setFlexibleAutoSubscribe(setFlexibleAutoSubscribeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000productId=1&autoSubscribe=false",
                signInputCaptor.getValue());
        assertEquals(
                "7f0e71e1d2216401bdf0ebda0fabfe4e4c1000d47e4c68eb693dac11779f033f",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/flexible/setAutoSubscribe",
                actualRequest.url().encodedPath());
    }

    /**
     * Set Locked Auto Subscribe(USER_DATA)
     *
     * <p>Set locked auto subscribe Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setLockedAutoSubscribeTest() throws ApiException, CryptoException {
        SetLockedAutoSubscribeRequest setLockedAutoSubscribeRequest =
                new SetLockedAutoSubscribeRequest();

        setLockedAutoSubscribeRequest.positionId("1");
        setLockedAutoSubscribeRequest.autoSubscribe(false);

        ApiResponse<SetLockedAutoSubscribeResponse> response =
                api.setLockedAutoSubscribe(setLockedAutoSubscribeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000positionId=1&autoSubscribe=false",
                signInputCaptor.getValue());
        assertEquals(
                "3a195934cb713ee1998b4fa336da6ec3a9a4b2087a91d11a2d5602c7af3474e0",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/locked/setAutoSubscribe", actualRequest.url().encodedPath());
    }

    /**
     * Set Locked Product Redeem Option(USER_DATA)
     *
     * <p>Set redeem option for Locked product Weight: 50
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setLockedProductRedeemOptionTest() throws ApiException, CryptoException {
        SetLockedProductRedeemOptionRequest setLockedProductRedeemOptionRequest =
                new SetLockedProductRedeemOptionRequest();

        setLockedProductRedeemOptionRequest.positionId("1");
        setLockedProductRedeemOptionRequest.redeemTo("");

        ApiResponse<SetLockedProductRedeemOptionResponse> response =
                api.setLockedProductRedeemOption(setLockedProductRedeemOptionRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000positionId=1&redeemTo=", signInputCaptor.getValue());
        assertEquals(
                "f8aaddc07f48085384e59233efb3421133330e9bcd0357b99332f1202fe03d70",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/locked/setRedeemOption", actualRequest.url().encodedPath());
    }

    /**
     * Subscribe Flexible Product(TRADE)
     *
     * <p>Subscribe Flexible Product * You need to open &#x60;Enable Spot &amp; Margin Trading&#x60;
     * permission for the API Key which requests this endpoint. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subscribeFlexibleProductTest() throws ApiException, CryptoException {
        SubscribeFlexibleProductRequest subscribeFlexibleProductRequest =
                new SubscribeFlexibleProductRequest();

        subscribeFlexibleProductRequest.productId("1");
        subscribeFlexibleProductRequest.amount(1d);

        ApiResponse<SubscribeFlexibleProductResponse> response =
                api.subscribeFlexibleProduct(subscribeFlexibleProductRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1&productId=1", signInputCaptor.getValue());
        assertEquals(
                "d71f21fc51817b324b37ac741557e5f0e37ba4c300b9b0dcf20dadffde1a1e1a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/simple-earn/flexible/subscribe", actualRequest.url().encodedPath());
    }

    /**
     * Subscribe Locked Product(TRADE)
     *
     * <p>Subscribe Locked Product * You need to open &#x60;Enable Spot &amp; Margin Trading&#x60;
     * permission for the API Key which requests this endpoint. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subscribeLockedProductTest() throws ApiException, CryptoException {
        SubscribeLockedProductRequest subscribeLockedProductRequest =
                new SubscribeLockedProductRequest();

        subscribeLockedProductRequest.projectId("1");
        subscribeLockedProductRequest.amount(1d);

        ApiResponse<SubscribeLockedProductResponse> response =
                api.subscribeLockedProduct(subscribeLockedProductRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1&projectId=1", signInputCaptor.getValue());
        assertEquals(
                "7ef22d632c2aec6bea9e728707f8eac15fbf16144341682080788f00ceb268ac",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/simple-earn/locked/subscribe", actualRequest.url().encodedPath());
    }

    /**
     * Get Collateral Record(USER_DATA)
     *
     * <p>Get Collateral Record * The time between &#x60;startTime&#x60; and &#x60;endTime&#x60;
     * cannot be longer than 30 days. * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are both
     * not sent, then the last 30 days&#39; data will be returned. * If &#x60;startTime&#x60; is
     * sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data beginning from
     * &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCollateralRecordTest() throws ApiException, CryptoException {
        String productId = "1";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetCollateralRecordResponse> response =
                api.getCollateralRecord(productId, startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "productId=1&startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "906323d23878072da9680bca3160b76d28b6ea07530e027f762757a381c263c0",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/flexible/history/collateralRecord",
                actualRequest.url().encodedPath());
    }

    /**
     * Get Flexible Redemption Record(USER_DATA)
     *
     * <p>Get Flexible Redemption Record * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; cannot be longer than 3 months. * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are both not sent, then the last 30 days&#39; data will be returned. * If
     * &#x60;startTime&#x60; is sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data
     * beginning from &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFlexibleRedemptionRecordTest() throws ApiException, CryptoException {
        String productId = "1";
        String redeemId = "1";
        String asset = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetFlexibleRedemptionRecordResponse> response =
                api.getFlexibleRedemptionRecord(
                        productId, redeemId, asset, startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "productId=1&redeemId=1&asset=&startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "d1703f8758c55672f9a39da68d446692dde9bf216f7ebef51b7093b2a9d37bd1",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/flexible/history/redemptionRecord",
                actualRequest.url().encodedPath());
    }

    /**
     * Get Flexible Rewards History(USER_DATA)
     *
     * <p>Get Flexible Rewards History * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; cannot be longer than 3 months. * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are both not sent, then the last 30 days&#39; data will be returned. * If
     * &#x60;startTime&#x60; is sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data
     * beginning from &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFlexibleRewardsHistoryTest() throws ApiException, CryptoException {
        String type = "Bonus";
        String productId = "1";
        String asset = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = null;
        Long size = null;
        Long recvWindow = null;
        ApiResponse<GetFlexibleRewardsHistoryResponse> response =
                api.getFlexibleRewardsHistory(type, productId, asset, startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "productId=1&asset=&startTime=1623319461670&endTime=1641782889000&type=Bonus&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "aaca82b4120f35ab3bf0bc811eb9e830f570191c637ef87b11b4e820934b3f50",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/flexible/history/rewardsRecord",
                actualRequest.url().encodedPath());
    }

    /**
     * Get Flexible Subscription Record(USER_DATA)
     *
     * <p>Get Flexible Subscription Record * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; cannot be longer than 3 months. * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are both not sent, then the last 30 days&#39; data will be returned. * If
     * &#x60;startTime&#x60; is sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data
     * beginning from &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFlexibleSubscriptionRecordTest() throws ApiException, CryptoException {
        String productId = "1";
        String purchaseId = "1";
        String asset = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetFlexibleSubscriptionRecordResponse> response =
                api.getFlexibleSubscriptionRecord(
                        productId,
                        purchaseId,
                        asset,
                        startTime,
                        endTime,
                        current,
                        size,
                        recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "productId=1&purchaseId=1&asset=&startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "e68ebd079318006615cac9e1f467bdc7c3ac82bf05a7180825541e5925b07e51",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/flexible/history/subscriptionRecord",
                actualRequest.url().encodedPath());
    }

    /**
     * Get Locked Redemption Record(USER_DATA)
     *
     * <p>Get Locked Redemption Record * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; cannot be longer than 3 months. * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are both not sent, then the last 30 days&#39; data will be returned. * If
     * &#x60;startTime&#x60; is sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data
     * beginning from &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getLockedRedemptionRecordTest() throws ApiException, CryptoException {
        String positionId = "1";
        String redeemId = "1";
        String asset = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetLockedRedemptionRecordResponse> response =
                api.getLockedRedemptionRecord(
                        positionId, redeemId, asset, startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "positionId=1&redeemId=1&asset=&startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "b969874fd814b72e7c29bdebdc319072c1dc23126f0a117b9b22f3617918204d",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/locked/history/redemptionRecord",
                actualRequest.url().encodedPath());
    }

    /**
     * Get Locked Rewards History(USER_DATA)
     *
     * <p>Get Locked Rewards History * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; cannot be longer than 3 months. * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are both not sent, then the last 30 days&#39; data will be returned. * If
     * &#x60;startTime&#x60; is sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data
     * beginning from &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getLockedRewardsHistoryTest() throws ApiException, CryptoException {
        String positionId = "1";
        String asset = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetLockedRewardsHistoryResponse> response =
                api.getLockedRewardsHistory(
                        positionId, asset, startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "positionId=1&asset=&startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "fa00e647d10a074646817619a9a8485086bbc8257eed00382562bf960d5f0143",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/locked/history/rewardsRecord",
                actualRequest.url().encodedPath());
    }

    /**
     * Get Locked Subscription Record(USER_DATA)
     *
     * <p>Get Locked Subscription Record * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; cannot be longer than 3 months. * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are both not sent, then the last 30 days&#39; data will be returned. * If
     * &#x60;startTime&#x60; is sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data
     * beginning from &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getLockedSubscriptionRecordTest() throws ApiException, CryptoException {
        String purchaseId = "1";
        String asset = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetLockedSubscriptionRecordResponse> response =
                api.getLockedSubscriptionRecord(
                        purchaseId, asset, startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "purchaseId=1&asset=&startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "bd233092b66eaad8df11be01a5a41670f67daa39dfc19880a9d14424471cfba7",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/locked/history/subscriptionRecord",
                actualRequest.url().encodedPath());
    }

    /**
     * Get Rate History(USER_DATA)
     *
     * <p>Get Rate History * The time between startTime and endTime cannot be longer than 1 year. *
     * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are both not sent, then the last 30
     * days&#39; data will be returned. * If &#x60;startTime&#x60; is sent but &#x60;endTime&#x60;
     * is not sent, the next 30 days&#39; data beginning from &#x60;startTime&#x60; will be
     * returned. * If &#x60;endTime&#x60; is sent but &#x60;startTime&#x60; is not sent, the 30
     * days&#39; data before &#x60;endTime&#x60; will be returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getRateHistoryTest() throws ApiException, CryptoException {
        String productId = "1";
        String aprPeriod = "DAY";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetRateHistoryResponse> response =
                api.getRateHistory(
                        productId, aprPeriod, startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "productId=1&aprPeriod=DAY&startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "0af754bef31bbc2eacb35fc0379a27fbebb9e93765a6b817a1c1a593149b478f",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/simple-earn/flexible/history/rateHistory",
                actualRequest.url().encodedPath());
    }
}
