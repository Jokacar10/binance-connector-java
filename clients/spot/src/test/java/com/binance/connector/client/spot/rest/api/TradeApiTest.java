/*
 * Binance Spot REST API
 * OpenAPI Specifications for the Binance Spot REST API  API documents:   - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)   - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.spot.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.spot.rest.model.AboveType;
import com.binance.connector.client.spot.rest.model.AllOrderListResponse;
import com.binance.connector.client.spot.rest.model.AllOrdersResponse;
import com.binance.connector.client.spot.rest.model.BelowType;
import com.binance.connector.client.spot.rest.model.CancelReplaceMode;
import com.binance.connector.client.spot.rest.model.CancelRestrictions;
import com.binance.connector.client.spot.rest.model.DeleteOpenOrdersResponse;
import com.binance.connector.client.spot.rest.model.DeleteOrderListResponse;
import com.binance.connector.client.spot.rest.model.DeleteOrderResponse;
import com.binance.connector.client.spot.rest.model.GetOpenOrdersResponse;
import com.binance.connector.client.spot.rest.model.GetOrderListResponse;
import com.binance.connector.client.spot.rest.model.GetOrderResponse;
import com.binance.connector.client.spot.rest.model.NewOrderRequest;
import com.binance.connector.client.spot.rest.model.NewOrderResponse;
import com.binance.connector.client.spot.rest.model.OpenOrderListResponse;
import com.binance.connector.client.spot.rest.model.OrderCancelReplaceRequest;
import com.binance.connector.client.spot.rest.model.OrderCancelReplaceResponse;
import com.binance.connector.client.spot.rest.model.OrderListOcoRequest;
import com.binance.connector.client.spot.rest.model.OrderListOcoResponse;
import com.binance.connector.client.spot.rest.model.OrderListOtoRequest;
import com.binance.connector.client.spot.rest.model.OrderListOtoResponse;
import com.binance.connector.client.spot.rest.model.OrderListOtocoRequest;
import com.binance.connector.client.spot.rest.model.OrderListOtocoResponse;
import com.binance.connector.client.spot.rest.model.OrderOcoRequest;
import com.binance.connector.client.spot.rest.model.OrderOcoResponse;
import com.binance.connector.client.spot.rest.model.OrderTestRequest;
import com.binance.connector.client.spot.rest.model.OrderTestResponse;
import com.binance.connector.client.spot.rest.model.OrderType;
import com.binance.connector.client.spot.rest.model.PendingAboveType;
import com.binance.connector.client.spot.rest.model.PendingSide;
import com.binance.connector.client.spot.rest.model.PendingType;
import com.binance.connector.client.spot.rest.model.Side;
import com.binance.connector.client.spot.rest.model.SorOrderRequest;
import com.binance.connector.client.spot.rest.model.SorOrderResponse;
import com.binance.connector.client.spot.rest.model.SorOrderTestRequest;
import com.binance.connector.client.spot.rest.model.SorOrderTestResponse;
import com.binance.connector.client.spot.rest.model.WorkingSide;
import com.binance.connector.client.spot.rest.model.WorkingType;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for TradeApi */
public class TradeApiTest {

    private TradeApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new TradeApi(apiClientSpy);
    }

    /**
     * Cancel All Open Orders on a Symbol
     *
     * <p>Cancels all active orders on a symbol. This includes orders that are part of an order
     * list. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "BNBUSDT";
        Double recvWindow = 5000d;
        ApiResponse<DeleteOpenOrdersResponse> response = api.deleteOpenOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=BNBUSDT&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "1c2ec70499498e5c5d2f4e98a7e24c74f2801642a8c3743d289dbfc1ca00c7a8",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel order
     *
     * <p>Cancel an active order. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteOrderTest() throws ApiException, CryptoException {
        String symbol = "BNBUSDT";
        Long orderId = 1L;
        String origClientOrderId = "";
        String newClientOrderId = "";
        CancelRestrictions cancelRestrictions = CancelRestrictions.ONLY_NEW;
        Double recvWindow = 5000d;
        ApiResponse<DeleteOrderResponse> response =
                api.deleteOrder(
                        symbol,
                        orderId,
                        origClientOrderId,
                        newClientOrderId,
                        cancelRestrictions,
                        recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=BNBUSDT&orderId=1&origClientOrderId=&newClientOrderId=&cancelRestrictions=ONLY_NEW&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "1a431901da232e9e41c7ed069d48d6bcdc05e75d38feb868fe574efa38418c52",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/order", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Order list
     *
     * <p>Cancel an entire Order list Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteOrderListTest() throws ApiException, CryptoException {
        String symbol = "BNBUSDT";
        Long orderListId = 1L;
        String listClientOrderId = "";
        String newClientOrderId = "";
        Double recvWindow = 5000d;
        ApiResponse<DeleteOrderListResponse> response =
                api.deleteOrderList(
                        symbol, orderListId, listClientOrderId, newClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=BNBUSDT&orderListId=1&listClientOrderId=&newClientOrderId=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "d9e6088fa5875f4f2e1d36eef74b7b7ac90d41a4e3f0269ff99d18698ddd59a0",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/orderList", actualRequest.url().encodedPath());
    }

    /**
     * New order
     *
     * <p>Send in a new order. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newOrderTest() throws ApiException, CryptoException {
        NewOrderRequest newOrderRequest = new NewOrderRequest();

        newOrderRequest.symbol("BNBUSDT");
        newOrderRequest.side(Side.BUY);
        newOrderRequest.type(OrderType.MARKET);

        ApiResponse<NewOrderResponse> response = api.newOrder(newOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=BNBUSDT&side=BUY&type=MARKET",
                signInputCaptor.getValue());
        assertEquals(
                "6486465768232440fc305256c99d50fa366fe8e7f0e7be813f78507f50e0cb4c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/order", actualRequest.url().encodedPath());
    }

    /**
     * Cancel an Existing Order and Send a New Order
     *
     * <p>Cancels an existing order and places a new order on the same symbol. Filters and Order
     * Count are evaluated before the processing of the cancellation and order placement occurs. A
     * new order that was not attempted (i.e. when &#x60;newOrderResult: NOT_ATTEMPTED&#x60; ), will
     * still increase the order count by 1. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderCancelReplaceTest() throws ApiException, CryptoException {
        OrderCancelReplaceRequest orderCancelReplaceRequest = new OrderCancelReplaceRequest();

        orderCancelReplaceRequest.symbol("BNBUSDT");
        orderCancelReplaceRequest.side(Side.BUY);
        orderCancelReplaceRequest.type(OrderType.MARKET);
        orderCancelReplaceRequest.cancelReplaceMode(CancelReplaceMode.STOP_ON_FAILURE);

        ApiResponse<OrderCancelReplaceResponse> response =
                api.orderCancelReplace(orderCancelReplaceRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=BNBUSDT&side=BUY&type=MARKET&cancelReplaceMode=STOP_ON_FAILURE",
                signInputCaptor.getValue());
        assertEquals(
                "b6808573e4dde9e77f712e393259a5802e1ab8bcab3342ac2f50b81cf5c99f38",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/order/cancelReplace", actualRequest.url().encodedPath());
    }

    /**
     * New Order list - OCO
     *
     * <p>Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately
     * cancels the other. * An OCO has 2 orders called the **above order** and **below order**. *
     * One of the orders must be a &#x60;LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT&#x60; order and
     * the other must be &#x60;STOP_LOSS&#x60; or &#x60;STOP_LOSS_LIMIT&#x60; order. * Price
     * restrictions * If the OCO is on the &#x60;SELL&#x60; side: *
     * &#x60;LIMIT_MAKER/TAKE_PROFIT_LIMIT&#x60; &#x60;price&#x60; &gt; Last Traded Price &gt;
     * &#x60;STOP_LOSS/STOP_LOSS_LIMIT&#x60; &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT
     * stopPrice&#x60; &gt; Last Traded Price &gt; &#x60;STOP_LOSS/STOP_LOSS_LIMIT stopPrice&#x60; *
     * If the OCO is on the &#x60;BUY&#x60; side: * &#x60;LIMIT_MAKER/TAKE_PROFIT_LIMIT price&#x60;
     * &lt; Last Traded Price &lt; &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT stopPrice&#x60; &lt;
     * Last Traded Price &lt; &#x60;STOP_LOSS/STOP_LOSS_LIMIT stopPrice&#x60; * OCOs add **2
     * orders** to the unfilled order count, &#x60;EXCHANGE_MAX_ORDERS&#x60; filter, and the
     * &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderListOcoTest() throws ApiException, CryptoException {
        OrderListOcoRequest orderListOcoRequest = new OrderListOcoRequest();

        orderListOcoRequest.symbol("BNBUSDT");
        orderListOcoRequest.side(Side.BUY);
        orderListOcoRequest.quantity(1d);
        orderListOcoRequest.aboveType(AboveType.STOP_LOSS_LIMIT);
        orderListOcoRequest.belowType(BelowType.STOP_LOSS);

        ApiResponse<OrderListOcoResponse> response = api.orderListOco(orderListOcoRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=BNBUSDT&side=BUY&belowType=STOP_LOSS&quantity=1&aboveType=STOP_LOSS_LIMIT",
                signInputCaptor.getValue());
        assertEquals(
                "db3271912437d1b5378885950c667387550503b3231f8929081cea96b3dd46bd",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/orderList/oco", actualRequest.url().encodedPath());
    }

    /**
     * New Order list - OTO
     *
     * <p>Places an OTO. * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. *
     * The first order is called the **working order** and must be &#x60;LIMIT&#x60; or
     * &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes on the order book. * The
     * second order is called the **pending order**. It can be any order type except for
     * &#x60;MARKET&#x60; orders using parameter &#x60;quoteOrderQty&#x60;. The pending order is
     * only placed on the order book when the working order gets **fully filled**. * If either the
     * working order or the pending order is cancelled individually, the other order in the order
     * list will also be canceled or expired. * When the order list is placed, if the working order
     * gets **immediately fully filled**, the placement response will show the working order as
     * &#x60;FILLED&#x60; but the pending order will still appear as &#x60;PENDING_NEW&#x60;. You
     * need to query the status of the pending order again to see its updated status. * OTOs add **2
     * orders** to the unfilled order count, &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60; filter and
     * &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderListOtoTest() throws ApiException, CryptoException {
        OrderListOtoRequest orderListOtoRequest = new OrderListOtoRequest();

        orderListOtoRequest.symbol("BNBUSDT");
        orderListOtoRequest.workingType(WorkingType.LIMIT);
        orderListOtoRequest.workingSide(WorkingSide.BUY);
        orderListOtoRequest.workingPrice(1d);
        orderListOtoRequest.workingQuantity(1d);
        orderListOtoRequest.pendingType(PendingType.LIMIT);
        orderListOtoRequest.pendingSide(PendingSide.BUY);
        orderListOtoRequest.pendingQuantity(1d);

        ApiResponse<OrderListOtoResponse> response = api.orderListOto(orderListOtoRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=BNBUSDT&workingQuantity=1&pendingSide=BUY&pendingQuantity=1&pendingType=LIMIT&workingSide=BUY&workingPrice=1&workingType=LIMIT",
                signInputCaptor.getValue());
        assertEquals(
                "85369190863be30874db1641d544803113baaf1fa702db81e7c8515e8b4f03e8",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/orderList/oto", actualRequest.url().encodedPath());
    }

    /**
     * New Order list - OTOCO
     *
     * <p>Place an OTOCO. * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised
     * of 3 orders. * The first order is called the **working order** and must be &#x60;LIMIT&#x60;
     * or &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes on the order book. * The
     * behavior of the working order is the same as the [OTO](#new-order-list---oto-trade). * OTOCO
     * has 2 pending orders (pending above and pending below), forming an OCO pair. The pending
     * orders are only placed on the order book when the working order gets **fully filled**. * The
     * rules of the pending above and pending below follow the same rules as the [Order list
     * OCO](#new-order-list---oco-trade). * OTOCOs add **3 orders** against the unfilled order
     * count, &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60; filter, and &#x60;MAX_NUM_ORDERS&#x60; filter.
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderListOtocoTest() throws ApiException, CryptoException {
        OrderListOtocoRequest orderListOtocoRequest = new OrderListOtocoRequest();

        orderListOtocoRequest.symbol("BNBUSDT");
        orderListOtocoRequest.workingType(WorkingType.LIMIT);
        orderListOtocoRequest.workingSide(WorkingSide.BUY);
        orderListOtocoRequest.workingPrice(1d);
        orderListOtocoRequest.workingQuantity(1d);
        orderListOtocoRequest.pendingSide(PendingSide.BUY);
        orderListOtocoRequest.pendingQuantity(1d);
        orderListOtocoRequest.pendingAboveType(PendingAboveType.STOP_LOSS_LIMIT);

        ApiResponse<OrderListOtocoResponse> response = api.orderListOtoco(orderListOtocoRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=BNBUSDT&workingQuantity=1&pendingSide=BUY&pendingQuantity=1&pendingAboveType=STOP_LOSS_LIMIT&workingSide=BUY&workingPrice=1&workingType=LIMIT",
                signInputCaptor.getValue());
        assertEquals(
                "d81e48c1257f42a9565c3e55dd2a40190bc0fe8eca7597fe62031e674a2f7213",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/orderList/otoco", actualRequest.url().encodedPath());
    }

    /**
     * New OCO - Deprecated
     *
     * <p>Send in a new OCO. * Price Restrictions: * &#x60;SELL&#x60;: Limit Price &gt; Last Price
     * &gt; Stop Price * &#x60;BUY&#x60;: Limit Price &lt; Last Price &lt; Stop Price * Quantity
     * Restrictions: * Both legs must have the same quantity. * &#x60;ICEBERG&#x60; quantities
     * however do not have to be the same * &#x60;OCO&#x60; adds **2 orders** to the unfilled order
     * count, &#x60;EXCHANGE_MAX_ORDERS&#x60; filter and the &#x60;MAX_NUM_ORDERS&#x60; filter.
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderOcoTest() throws ApiException, CryptoException {
        OrderOcoRequest orderOcoRequest = new OrderOcoRequest();

        orderOcoRequest.symbol("BNBUSDT");
        orderOcoRequest.side(Side.BUY);
        orderOcoRequest.quantity(1d);
        orderOcoRequest.price(400d);
        orderOcoRequest.stopPrice(1d);

        ApiResponse<OrderOcoResponse> response = api.orderOco(orderOcoRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=BNBUSDT&side=BUY&stopPrice=1&quantity=1&price=400",
                signInputCaptor.getValue());
        assertEquals(
                "7a44ec1f11be815620aaa760d66d510d4632c91aedca34aaa382ee4a9ef7f702",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/order/oco", actualRequest.url().encodedPath());
    }

    /**
     * Test new order
     *
     * <p>Test new order creation and signature/recvWindow long. Creates and validates a new order
     * but does not send it into the matching engine. Weight: |Condition| Request Weight|
     * |------------ | ------------ | |Without &#x60;computeCommissionRates&#x60;| 1| |With
     * &#x60;computeCommissionRates&#x60;|20|
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderTestTest() throws ApiException, CryptoException {
        OrderTestRequest orderTestRequest = new OrderTestRequest();

        orderTestRequest.symbol("BNBUSDT");
        orderTestRequest.side(Side.BUY);
        orderTestRequest.type(OrderType.MARKET);

        ApiResponse<OrderTestResponse> orderTestResponseApiResponse = api.orderTest(orderTestRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=BNBUSDT&side=BUY&type=MARKET", signInputCaptor.getValue());
        assertEquals(
                "6486465768232440fc305256c99d50fa366fe8e7f0e7be813f78507f50e0cb4c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/order/test", actualRequest.url().encodedPath());
    }

    /**
     * New order using SOR
     *
     * <p>Places an order using smart order routing (SOR). Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sorOrderTest() throws ApiException, CryptoException {
        SorOrderRequest sorOrderRequest = new SorOrderRequest();

        sorOrderRequest.symbol("BNBUSDT");
        sorOrderRequest.side(Side.BUY);
        sorOrderRequest.type(OrderType.MARKET);
        sorOrderRequest.quantity(1d);

        ApiResponse<SorOrderResponse> response = api.sorOrder(sorOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=BNBUSDT&side=BUY&quantity=1&type=MARKET",
                signInputCaptor.getValue());
        assertEquals(
                "84bb7809eacf584b9d7dccae40864b17ca8fcf3de423b05e0a171b8a0c67ed62",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/sor/order", actualRequest.url().encodedPath());
    }

    /**
     * Test new order using SOR
     *
     * <p>Test new order creation and signature/recvWindow using smart order routing (SOR). Creates
     * and validates a new order but does not send it into the matching engine. Weight: | Condition
     * | Request Weight | | --------- | -------------- | | Without
     * &#x60;computeCommissionRates&#x60; | 1 | | With &#x60;computeCommissionRates&#x60; | 20 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sorOrderTestTest() throws ApiException, CryptoException {
        SorOrderTestRequest sorOrderTestRequest = new SorOrderTestRequest();

        sorOrderTestRequest.symbol("BNBUSDT");
        sorOrderTestRequest.side(Side.BUY);
        sorOrderTestRequest.type(OrderType.MARKET);
        sorOrderTestRequest.quantity(1d);

        ApiResponse<SorOrderTestResponse> response = api.sorOrderTest(sorOrderTestRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=BNBUSDT&side=BUY&quantity=1&type=MARKET", signInputCaptor.getValue());
        assertEquals(
                "84bb7809eacf584b9d7dccae40864b17ca8fcf3de423b05e0a171b8a0c67ed62",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/sor/order/test", actualRequest.url().encodedPath());
    }
}
